[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Follow the workflow",
    "section": "",
    "text": "Welcome\n\n\n\n\n\n\nImportant\n\n\n\nThis book is a work in progress. Many parts are more personally addressed to the project I initially wrote this for. I will gradually try to adapt it to the general public so it doesn’t contain out of context mentions.\n\n\nThis book was born as an early attempt to introduce researchers to best coding practices. Many researchers only write code for themselves, and thus don’t feel the urge to cleanly organise and share it. The book has two main aims:\n\nWork with code collaboratively: use git and GitHub.\nMake your code easily accessible for other programmers: create an R package.\n\nWhen I started, I didn’t know much about R myself, so writing this was also helpful to me. It started as a rather short introduction (and I still think it is to some extent), but it keeps growing while I learn about new tools that I find useful for our workflow.\nI don’t expect you to read everything linearly. You’re encouraged to gradually develop your own package or contribute to an existing one and come back here when you need some help or a refresher. You can also use the search bar at the top left to look for specific keywords and find the relevant parts in the book. Reading code from other experienced programmers can also get you quite far without diving too deep into passively reading texts like this. If that sounds appealing, I recommend checking the source code for R packages from tidyverse or rOpenSci.\nThis book is prepared with Quarto, but I also used git and R! The book is open source and stored in GitHub. If you find any mistake or some part that can be improved, you can contribute! Look for the Edit this page button, which will take you to GitHub to easily suggest changes.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "Use git and GitHub",
    "section": "",
    "text": "This is the git and GitHub part.\nthis is a test change",
    "crumbs": [
      "Use git and GitHub"
    ]
  },
  {
    "objectID": "clone-repo.html",
    "href": "clone-repo.html",
    "title": "1  Cloning the repository",
    "section": "",
    "text": "To get started with Git, you need your operating system to recognize Git commands. We will assume you are on Windows, so you will have to install Git from here. If you do not know whether it is the 32 or 64 bits version, you most likely need the 64 bit one. You should now have something called ‘Git Bash’ installed, which is like a command line tool (similar to Windows CMD). You can open Git Bash inside a specific directory (this is just a technical name for folders and I will use it from now on) by right-clicking your desired directory in the file explorer and selecting ‘Open Git Bash here’. However, I would recommend you to learn some basic commands to navigate from the command line itself (from now on, writing &lt;some-text&gt; is not part of the command, I just use it as a placeholder for what you need to write there):\n\nPrint your current directory:\npwd\nThis is just useful so you can see where you are right now.\nList files from your current directory:\nls\nSuppose you do not know the exact path to follow but you know it is inside a certain subdirectory from the one you are in right now. Listing everything in the current directory with ls is a useful way to spot which subdirectory you are looking for, so that you can then navigate inside it with cd.\nMove to another directory relative to the one you are in right now:\ncd &lt;relative-path-where-to-move&gt;\n\nYou can use ls and cd &lt;relative-path&gt; repeatedly until you are in the directory where you want to place a subdirectory containing the repository. Again, you can double check that using pwd.\nWe assume here that the repository you want to contribute to already exists. You can go to its page on GitHub and copy the URL as seen in the image below:\n\n\n\n\n\n\n\n\n\nThe git terminology used for ‘downloading’ a repository to our local file system is ‘cloning’. We can clone a remote repository (in this case from GitHub) using the following command:\ngit clone &lt;url-you-copied&gt;\nThis is called cloning via HTTPS. A browser should open and ask you to introduce your GitHub credentials. There are other ways of cloning like SSH, but that is out of the scope of this guide.",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Cloning the repository</span>"
    ]
  },
  {
    "objectID": "pull-remote.html",
    "href": "pull-remote.html",
    "title": "2  Pulling remote changes",
    "section": "",
    "text": "Now a new directory should have been created with the content of the repository in your local file system. From now on we will see the basic git commands that you would need in daily usage. We assume you are inside the repository. We explain them with an example.\nSuppose you want to start contributing to this repository. A good practice (and one that we will enforce to use) is to make your own code changes in a ‘different place’ than the ones you currently see in the repository. The things you see now are in what it is called the ‘main branch’, and you will make your code changes in a ‘new branch’, which will start with the same content as the main one, but will then evolve with different changes. If you have not done anything yet, you should be in the main branch (maybe it is called ‘main’ or ‘master’, these are just conventions, but I will assume it is called ‘main’). You can use the command git status to check this (do not mind that my terminal looks different in the screenshots, you can use the same commands in Git Bash):\n\n\n\n\n\n\n\n\n\nYour local version of a repository does not need to match the remote version (the one we store in GitHub in this case), but before you start your work on a new branch, you should keep your main branch up to date in case someone added new code in the GitHub repository since the last time you checked. We get any new remote changes to the local repository by using the command\ngit pull\n\n\n\n\n\n\n\n\n\nIn this case I already had all the remote changes, and that is why the message says ‘Already up to date’, but the message will be different if you had missing changes. This is the ‘easy way’ to do it. The command git pull tries to fetch changes from the equivalent remote branch, i.e., the one that has the same name on remote as it has on your local repository. This may not always work as expected so there is a way to always specify from which remote branch you want to get these changes (and I highly recommend always using it explicitly):\ngit pull origin &lt;name-of-remote-branch&gt;\nFor example, imagine you asked someone for help on your own branch and they added some new changes on your branch, that you do not have locally. Then, if your branch is called my-branch, and you are already on your branch locally, you would want to use the command\ngit pull origin my-branch\nLikewise, for the first example shown here (keeping the main branch updated), I would always be explicit:\ngit pull origin main",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Pulling remote changes</span>"
    ]
  },
  {
    "objectID": "create-branch.html",
    "href": "create-branch.html",
    "title": "3  Creating our own branch",
    "section": "",
    "text": "After the pull, we are now safely up to date with the remote changes. Now it is time to learn how to create our own ‘branch’, from which we will start working on new code. We use the following command:\ngit checkout -b &lt;name-of-branch&gt;\n\n\n\n\n\n\n\n\n\nThe command git checkout &lt;name-of-branch&gt; is used to change from one branch to another (so that you will now see the files and changes that are in that branch). Additionally, if we add the -b option, it will create the branch with the given name if it does not already exist, which is our case in this example. The branch name should be something like author/name-of-branch. Thus, some common practices for naming your branches (and that we should follow) are:\n\nThey do not contain caps (all lowercase)\nWords are separated with dashes (-)\nThe name includes the author and some descriptive name separated by a slash (/)\nThe descriptive name should ideally start with an action (a verb) in imperative style (fix, create, test…).\n\nIf Ermenegildo wants to create some code for preprocessing bilateral trade data, an acceptable branch name could be ermenegildo/preprocess-bilateral-trade-data.",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Creating our own branch</span>"
    ]
  },
  {
    "objectID": "add-changes.html",
    "href": "add-changes.html",
    "title": "4  Adding changes to our branch",
    "section": "",
    "text": "Now you are in your own branch and you can start working on your changes. While you work on them, you should keep track of changes with git. We can add all changes using the command\ngit add .\nHere the dot means ‘this directory’, which essentially adds all new changes, i.e. all things inside the directory. We can add just a specific file instead using the command\ngit add &lt;relative-name-of-file&gt;\n\n\n\n\n\n\n\n\n\nAfter adding our changes, we must ‘commit’ them. This commit step is what actually saves your changes in the git history. You do this with the command\ngit commit -m 'Some descriptive message for your changes'\nA common practice for commit messages is to start them with a verb in infinitive (imperative style), indicating an action that was performed, e.g., 'Create tests for bilateral trade data preprocessing'.\n\n\n\n\n\n\n\n\n\nA common practice is to make small commits, that is, include just a few changes in each commit, so that it is easier to keep track of your work’s history, instead of just having a single commit when you are done with everything. Ultimately, the amount of commits is your decision, but should not be just one commit per branch.",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Adding changes to our branch</span>"
    ]
  },
  {
    "objectID": "push-changes.html",
    "href": "push-changes.html",
    "title": "5  Pushing our changes",
    "section": "",
    "text": "After committing, we now have our changes in local git history, but we should probably also add them to the remote GitHub repository. We do this using the command\ngit push origin &lt;name-of-branch&gt;\nNow you should be able to see your changes in your own branch from GitHub itself, you just need to select your own branch instead of the main one.\nYou should remember to push your changes regularly to the remote repository. Otherwise you risk having a bunch of code features in your local computer that could be lost if something happened to it. This is aligned with the previous suggestion of creating many smaller commits as opposed to giant ones, so that you can also push them more frequently.",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pushing our changes</span>"
    ]
  },
  {
    "objectID": "create-pr.html",
    "href": "create-pr.html",
    "title": "6  Creating a pull request",
    "section": "",
    "text": "Suppose you are done with your changes and you want to add these to the main branch. Mixing one branch with another is known as ‘merging’. In this case we would like to merge our new branch with the main branch. This can be done forcefully, but the common practice we will be following is to create what is known as a ‘Pull request’ from our branch into the main one, and we do this directly from GitHub, once we have pushed all of our changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere you can see all the changes you made (that differ from the main branch) before clicking again ‘Create pull request’. Then you will see the following, where you should add some title and description to explain what you have done. You finally click ‘Create pull request’ again.\n\n\n\n\n\n\n\n\n\nNow the Pull Request (often abbreviated as PR) is created and the next step is to ask for someone’s review.\n\n\n\n\n\n\n\n\n\nIdeally these changes would not be merged until someone else reviews your code. This person might find things you have to change and request these changes before merging, so you would have to keep working on your branch until they are satisfied. Then they would accept your changes and you would be ready to merge your branch into the main one, and the process would be done.\nHowever, sometimes there is an additional step that must be passed before merging, which is related to automatic code checks, e.g. check whether your code is well formatted and whether it passes all tests successfully. If configured, these can run automatically when creating a Pull Request. We will indeed work with them, but we will explain these automatic checks better in the Automatic checks on Pull Requests section.\nWhile working on your own branch, others may have merged their own branches into the main branch and then your own branch would be outdated. When creating a Pull Request yourself, you should make sure your branch is also up to date with everything already on the main branch. Recall from the pulling remote changes section that we can do this with the command\ngit pull origin main\nEven if you are locally on your own branch and directly try to fetch changes from a different remote one (in this case main), this works as expected, that is, it tries to merge all new changes from the main branch into your own local one. This automatic merge works most of the times, but sometimes you may find conflicts, because the program does not know how to combine everything neatly. If this happens, you must manually check which parts of the code should be kept. In the next section we explain how to solve conflicts.",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Creating a pull request</span>"
    ]
  },
  {
    "objectID": "solve-conflicts.html",
    "href": "solve-conflicts.html",
    "title": "7  Solving conflicts",
    "section": "",
    "text": "As noted in the previous section, sometimes when you git pull from another branch or from the same remote one (if you are missing some changes), you can find conflicts. A conflict looks like this:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nthis is my content\nthat I just added\n=======\nthis is some different conflicting content\nfrom the branch I pulled from\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; some_branch_name\nSo in a conflict, there are at least three lines the were added by git to separate the conflicting parts. The conflict starts at the line &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, and until we get to the ======= line, the lines in between are the content we added. Then from this one until the end &gt;&gt;&gt;&gt;&gt;&gt;&gt; some_branch_name, the lines in between are the content that someone else added and we did not have yet. Then solving a conflict essentially means removing these three lines added by git. We have three options here. You will have to decide which one you want depending on the situation:\n\nKeep only our content. Solving the conflict would involve removing all lines except:\nthis is my content\nthat I just added\nKeep only the other content. We remove everything except:\nthis is some different conflicting content\nfrom the branch I pulled from\nKeep some (or all) content from both parts, or even adapt it adding other things. We remove the three lines added by git and everything else we do not want to keep, leaving something like a mix:\nthis is my content\nthat I just added\nthis is some different conflicting content\n\nIf you have to find conflicts (I advise to do it manually), you could use some text finding tool in your editor, and look for the text HEAD, as this always appears in the first line of a conflict. After you solved all conflicts, you have to do the rest of the steps explained in previous sections, involving git add and git commit, because a pull also counts as a code change, so you have to make a commit from it. In case you are wondering, when you perform a pull without conflicts, you are not creating a commit yourself but git does it for you, automatically. So whether you solved the conflicts or git did it for you, there will always be a commit representing it.",
    "crumbs": [
      "Use git and GitHub",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Solving conflicts</span>"
    ]
  },
  {
    "objectID": "r.html",
    "href": "r.html",
    "title": "Create an R package",
    "section": "",
    "text": "This is the R package part.",
    "crumbs": [
      "Create an R package"
    ]
  },
  {
    "objectID": "project-structure.html",
    "href": "project-structure.html",
    "title": "8  Project structure",
    "section": "",
    "text": "It seems clear that even though we would work fine with bare R scripts that are run directly, when working on a large project it makes sense to have some kind of file structure, to keep everything organized. You can build your ad-hoc file structures, and you could probably come up with something rather simple. Here, instead, we will focus on using the standard structure of an R package. This is a standard everyone has to follow if they want their projects to turn into packages which can be publicly downloaded by anyone from the CRAN repositories. Just the same way you do, e.g., install.packages(tidyverse) to install all Tidyverse packages, if you follow this standard R package structure, you can upload your package and one could do install.packages(your_package) the same way.\nEven if you do not want to upload a package, there are still advantages if you follow this structure. This is the one we will follow, so the rest of this section will try to explain its different parts, that will all become part of our workflow.\nThis is the whole structure of an R package:\n\n\n\n\n\n\n\n\n\nLuckily, there are a lot of files there that you do not need to know about, at least for now, so we will try to explain the most important ones in the next sections.\nThere is a whole R packages book which I followed myself to setup the basics for our project. It is very well written and available for free online, so if you are interested in knowing more about R packages and their project structure, I recommend checking the book.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Project structure</span>"
    ]
  },
  {
    "objectID": "renv.html",
    "href": "renv.html",
    "title": "9  Virtual environments with renv",
    "section": "",
    "text": "We just mentioned we were going to use the R package structure, and it seems R package developers do not use renv… Or do they? At least they do not seem to include renv related files in their package repositories… Well, why should we use it then? While writing this guide I was a bit confused myself about mixing both things, but my conclusion was that it just does not hurt in any way, renv just makes things easier without apparent drawbacks (do tell me if you know of any). When creating packages, you want to make sure they work on fresh installations, i.e., computers that do not have anything unnecessary installed. The package creation process as we will use it, does not need to know anything about renv, so we should be fine. The packages use their own file called DESCRIPTION which includes information about the other packages it needs as dependencies, as we will see later on. So we can just try to benefit from using virtual environments.\nOK, but what are virtual environments? This is a fancy term, but its practical meaning is quite simple. First consider the following:\n\nIf you are not using them, it means you just have a global R installation in your computer, and whenever you install a package, it is installed globally.\nIf you want to run someone’s code and they use a bunch of packages that you usually do not, you would have to install all of them to be able to run their code, and these would mix with all your other packages. If you want to uninstall them after that, you would have to do a lot of manual work to make sure you know all of them (some package dependencies could have also been installed, and you cannot be sure if they were only used for these packages or also some other package that you already had).\nIf you want to write some code that uses some packages, and you want another person to run it, you should make a list of the packages used only in this project, because they should not have to install any other packages you have from other projects but are not necessary here. If you do not even make this ‘package list’, the other person should have to go through your whole code or run it and install a new package every time the code fails because of a missing one. Overall, this is a poor experience.\n\nVirtual environments try to fix this. Essentially, they provide a ‘local’ installation of packages, that are only visible inside your project, and do not get mixed at all with those from your global R installation or from other individual projects. In practice, a virtual environment is just a folder containing installed packages, isolated from the folder that contains your global R installation. It is like having several different R installations, each one with their own packages and versions.\nChances are you follow this guide with an existing repository that is already using renv (then you can skip the renv::init() step). If this were not the case, open an R prompt in the root directory of your project and run inside the prompt:\nrenv::init()\nIt will probably ask to close and reopen a clean prompt. After that, every time we open an R prompt inside our project, it will automatically use renv to work within a virtual environment. If you use renv for the first time but on a project that already uses it, when you open the R prompt in its root directory, the renv package will be installed automatically.\nNow that we have renv, we can, for example, install a testing package with install.packages(\"testthat\") and this will not be a global installation, which means it will only work inside this project. This is a way of isolating your project dependencies and making your projects reproducible, by letting others know exactly which packages your code needs to run, and not add unnecessary ones that you may have because of other projects, as we mentioned previously.\nThe ‘list’ of required packages for the project, along with their versions, which is used by renv to manage the virtual environment, is in a file called renv.lock. After installing new packages, this file is not updated automatically and we have to do it manually by running\nrenv::snapshot()\nThis will update the renv.lock file with all the packages renv finds are used in your code. If for some reason you need to install a package not explicitly used in the code, this may fail to recognize it. In that case, you should instead explicitly call renv::snapshot(type=\"all\") to force every package in your renv environment to be added to renv.lock. You should push this file to the repository. If someone else wants to reproduce your code, then they may have to run\nrenv::restore()\nwhich will install any packages from renv.lock that they may still not have installed, but again, only on a project level, not conflicting with their global R installation. If you use GitHub with others, then you might also need to do this every time you pull remote changes and someone else has included a new package, so that you are then up to date with them. In any case, when opening the R shell, it will probably remind you that there are missing packages in your virtual environment with a message:\n\n\n\n\n\n\n\n\n\nAnd this is basically all you need to start using a virtual environment, keeping in mind the commands\n\nrenv::snapshot(): add new required packages to renv.lock file\nrenv::restore(): install packages from renv.lock that you do not have yet\n\nI wrote this introduction to renv by reading their own package documentation. If you want to learn more about it, you can read it yourself at their package website.\nWhile this is not directly related to renv usage, I wanted to highlight here that in Windows you may have errors trying to install some R packages. Most of the times this may be related to missing operating system dependencies or commands. In Windows this should be easily fixable by installing the version of Rtools that matches with your R version. After selecting the version you can download it by clicking the first installer link. After installing Rtools, you can try again to install the R packages you wanted.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Virtual environments with renv</span>"
    ]
  },
  {
    "objectID": "write-code.html",
    "href": "write-code.html",
    "title": "10  Writing code",
    "section": "",
    "text": "Looking back at the package’s file structure, it is in the R/ directory where we will put all the main code. The R files stored here must not contain any top-level code, that is, it must all be inside functions. We can add more than one function in each file if they are somehow related, but there must not be too many either. If a file becomes too large and it has several functions inside, consider splitting it into shorter files.\nTake the following code as an example, written by our colleague Justin (you do not have to understand the code, you can keep reading). We save it in R/sources.R.\n#' Create a new dataframe where each row has a year range into one where each\n#' row is a single year, effectively 'expanding' the whole year range\n#'\n#' @param trade_sources A tibble dataframe\n#' where each row contains the year range\n#'\n#' @returns A tibble dataframe where each row\n#' corresponds to a single year for a given source\n#'\n#' @export\n#'\n#' @examples\n#' trade_sources &lt;- tibble::tibble(\n#'   Name = c(\"a\", \"b\", \"c\"),\n#'   Trade = c(\"t1\", \"t2\", \"t3\"),\n#'   Info_Format = c(\"year\", \"partial_series\", \"year\"),\n#'   Timeline_Start = c(1, 1, 2),\n#'   Timeline_End = c(3, 4, 5),\n#'   Timeline_Freq = c(1, 1, 2),\n#'   `Imp/Exp` = \"Imp\",\n#'   SACO_link = NA,\n#' )\n#' expand_trade_sources(trade_sources)\nexpand_trade_sources &lt;- function(trade_sources) {\n  non_na_cols &lt;- c(\"Trade\", \"Timeline_Start\", \"Timeline_End\", \"Timeline_Freq\")\n  trade_sources |&gt;\n    dplyr::filter(!.any_na_col(non_na_cols)) |&gt;\n    .expand_trade_years() |&gt;\n    dplyr::mutate(\n      Name = dplyr::if_else(\n        Info_Format == \"year\", paste(Name, Year, sep = \"_\"), Name\n      ),\n      ImpExp = `Imp/Exp`,\n      In_Saco = as.integer(!is.na(SACO_link)),\n    )\n}\n\n.expand_trade_years &lt;- function(trade_sources) {\n  trade_sources &lt;- dplyr::mutate(trade_sources, No = dplyr::row_number())\n\n  trade_sources |&gt;\n    dplyr::group_by(No) |&gt;\n    tidyr::expand(Year = seq(Timeline_Start, Timeline_End, Timeline_Freq)) |&gt;\n    dplyr::inner_join(trade_sources, by = \"No\")\n}\n\n.any_na_col &lt;- function(cols_to_check) {\n  dplyr::if_any(dplyr::all_of(cols_to_check), is.na)\n}\nIn this sample code there are some things to keep in mind:\n\nAll the code is written inside functions, and there are three of them. The name of two of them starts with a dot. This is a convention for private functions. Private functions are just helpers that are used in other functions from the same file, they do not need to be used from outside.\nThe functions that are not private, are then called public, and those are the ones that we want to ‘export’, in the sense that we want to allow for them to be used from outside this file. In our sources.R example, the first function is public.\nThe public function has a large commented section before it, each line starting with #'. This is a special type of comment and it is considered documentation. Every public function must be documented in the same way (more on this special function documentation in the next section). The private functions can be introduced by explanatory comments if you consider it necessary, but they should be normal comments instead (starting with just #, without the single quote).\n\nThe most important take from here anyway is that these files should contain all the code inside functions and nothing outside them.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Writing code</span>"
    ]
  },
  {
    "objectID": "function-docs.html",
    "href": "function-docs.html",
    "title": "11  Function documentation",
    "section": "",
    "text": "The special commented section seen in the previous example will be used by a package called roxygen2. We have to follow this exact syntax, so that this package can automatically build a really neat documentation of our package for us. Let’s try to understand its basic structure. For reference, these were the different parts:\n\nA small description of the function, nothing else.\n\n#' Create a new dataframe where each row has a year range into one where each\n#' row is a single year, effectively 'expanding' the whole year range\n\nA small description of each parameter the function receives. It should be like:\n\n#' @param param_name_1 Description of param 1\n#' @param param_name_2 Description of param 2\n#' ...\nAs you see here I think it is OK to add line breaks in between, as long as each parameter starts with @param.\n#' @param trade_sources A tibble dataframe\n#' where each row contains the year range\n\nA small description of the value the function returns. It should start with @returns.\n\n#' @returns A tibble dataframe where each row\n#' corresponds to a single year for a given source\n\nA simple line containing @export to indicate the function can be used in the package, i.e., it is public.\n\n#' @export\n\nA ‘code’ section of examples to illustrate the function’s behavior. It must start with @examples, and after that you can write usual R code. When this is processed, it automatically runs the code and adds some lines with its output in the documentation.\n\n#' @examples\n#' trade_sources &lt;- tibble::tibble(\n#'   Name = c(\"a\", \"b\", \"c\"),\n#'   Trade = c(\"t1\", \"t2\", \"t3\"),\n#'   Info_Format = c(\"year\", \"partial_series\", \"year\"),\n#'   Timeline_Start = c(1, 1, 2),\n#'   Timeline_End = c(3, 4, 5),\n#'   Timeline_Freq = c(1, 1, 2),\n#'   `Imp/Exp` = \"Imp\",\n#'   SACO_link = NA,\n#' )\n#' expand_trade_sources(trade_sources)\nThese options are enough to get us started with a nice documentation. In the Writing articles section we will learn how to generate and see this documentation. In this example, it would look something like this (note the autogenerated example code output):",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Function documentation</span>"
    ]
  },
  {
    "objectID": "pkg-data.html",
    "href": "pkg-data.html",
    "title": "12  Package data",
    "section": "",
    "text": "Some of the data we have to work with might be very large. If the final datasets we want to produce are too large, we can’t directly include them in the package because there are size limits and recommendations. In that case, we will have to export them as functions. In this way, the package itself won’t contain the output dataset, but the user will have to generate it through running a function, so it will be stored in their own computer. An example of this is our function get_wide_cbs(). Unless we generate the dataset ourselves in the function, we will also probably be using a very large input dataset which we just process somehow. For reading large datasets, see the relevant Reading large files section.\nFrom now on, in this section we assume that you have some small datasets (maybe up to a couple of megabytes) as inputs. We will go through both public and private ones. The public ones are those that you want to export to users of your package, and the private ones are only intended for being used in your own code.\nLet’s start with the exported datasets. The whole aim of this is to allow users (or even our own code) to access them easily by writing my_pkg::my_dataset. In order to achieve this, you must follow these steps:\n\nCreate a file in data-raw/my_dataset.R. Scripts inside the data-raw folder aren’t included as part of the package. They will just be helpers for us to generate the actual data. Inside this file we do some processing and, assuming we have a variable called my_dataset, we end the script by calling usethis::use_data(my_dataset). This will automatically create an .rda file in data/my_dataset.rda. We have to manually run this script. After that, we can now refer to the dataset as my_pkg::my_dataset.\nYou can directly create your data in the script data-raw/my_dataset.R, or you can make it rather short by just importing some data from another raw file. In this case, I recommend having the raw file as a CSV in the inst/extdata folder, say, inst/extdata/my_raw_dataset.csv. This is for accessibility, so that everyone can see where this data comes from regardless of whether they know how to read an .rda file or not. A data-raw/my_dataset.R script could then look like:\n\nmy_dataset &lt;- here::here(\"inst\", \"extdata\", \"my_raw_dataset.csv\") |&gt;\n  readr::read_csv()\n\nusethis::use_data(my_raw_dataset, overwrite = TRUE)\nEvery time you introduce some change in the raw CSV file, you would have to run this script again. The overwrite = TRUE is exactly for this purpose, so that the my_dataset.rda file is overwritten with the updated data.\n\nDocument your dataset. In the previous section we learned how to document functions. Datasets aren’t functions, but they’re documented very similarly. We start by creating a file R/my_dataset.R. Note that the name matches that of data-raw/my_dataset.R. It doesn’t need to match that of the variable used with usethis::use_data(), but they should match each other. You can define more than one dataset in the same file if you think they’re related, so then you can also use a more general name for the file. This is how you would document your dataset, also using roxygen2 comments:\n\n#' Title of my dataset\n#'\n#' My description of my dataset\n#'\n#' @format\n#' What my dataset is. I would ideally make it a tibble and explain all\n#' columns. My dataset contains the following columns:\n#' - `column_1`: My explanation of column 1.\n#' - `column_2`: My explanation of column 2.\n#' - `column_3`: My explanation of column 3.\n#'\n#' @source Where my data comes from. Maybe an external link if you have one.\n\"my_dataset\"\nAs you can see, we use roxygen2 style comments right before a line containing a character vector with the name of our dataset, in this case \"my_dataset\". Now your dataset will be correctly documented after doing devtools::document() and pkgdown::build_site()/pkgdown::build_reference().\nNow we should talk about internal data. This is data that only the developers of the package themselves use throughout the code. This could be either actual tibble datasets or just bare constants. Any value that doesn’t change and you would like to share throughout the whole package code applies for this. Creating internal data is quite similar to exported data:\n\nCreate a file data-raw/constants.R if it doesn’t already exist. For internal data, all of them should be defined in this same file. The file could look like this:\n\nmy_constant_number &lt;- 0.65\nmy_constant_name &lt;- \"name\"\nmy_constant_tibble &lt;- tibble::tribble(\n  ~col_1, ~col_2,\n  1,      2,\n  3,      4\n)\n\nusethis::use_data(\n  my_constant_number,\n  my_constant_name,\n  my_constant_tibble,\n  internal = TRUE,\n  overwrite = TRUE\n)\nAs you can see, you can pass more than one variable to usethis::use_data(). We should include all our constants in the same call to this function. In addition, it must also include the internal = TRUE option to identify this as internal data.\n\nManually run the previous file. This will create a single file in R/sysdata.rda, which contains all your internal data. You can now refer to these data the same way as for exported data, e.g., my_pkg::my_constant_tibble or my_pkg::my_constant_number, but these will only be available through the package’s code, and won’t be exported to the package users. Again, any time you want to add new internal data or modify the existing entries, you will have to manually run that script again.\n\nWhether some data is worth being exported as part of the package or just used as internal, this is your decision, but now you know how to implement both. This section was heavily inspired by the Data chapter in the R Packages book, which I recommend reading if you want to dive deeper.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Package data</span>"
    ]
  },
  {
    "objectID": "write-tests.html",
    "href": "write-tests.html",
    "title": "13  Writing tests",
    "section": "",
    "text": "So we just wrote a function, we are done with it, we now move to another function… No. You probably thought that we should check somehow that this function is indeed correct and it does what you expect. Right now it would be easy to just load the function in an R prompt and try some examples on it, but what if the next month someone has to make a change in this code? They would have to do this manual testing again to make sure they did not break any functionality. What if they need to change dozens of functions? How much time will they spend on testing all of them?\nI think you can understand that this is really time consuming and that there is a better way. Tests can be automatized. We can write some tests whenever we create a new function, that together prove the function does what we expect, and if later on we add some changes to the function, we already have a test that can be run automatically to see if the function is still correct. Of course, this is not completely accurate. Maybe when we changed the function, some of its functionality was also changed, so the test is not accurate anymore and has to be tweaked as well, to represent what we really want. But this is still much less work than always testing the function manually in an R prompt, and eventually you just get used to it.\nThe package that is used to write tests and is well integrated into the R package creation workflow is testthat. We will be using it to write our automated tests. Again, looking at the structure of an R package, the tests go into (surprise!) the directory tests/. In this directory there is a file called testthat.R that setups testthat and should not be changed, and the actual tests that we write will go into the tests/testthat/ subdirectory. The convention is to name the test files the same way as the R files but with a test- prefix. In our case, for example, if we have an R file in R/sources.R, then our test file should be tests/testthat/test-sources.R. Let’s see how one of our tests could look like:\nlibrary(\"testthat\")\n\ntest_that(\"trade source data is expanded from year range to single year rows\", {\n  trade_sources &lt;- tibble::tibble(\n    Name = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    Trade = c(\"t1\", \"t2\", \"t3\", NA, \"t5\"),\n    Info_Format = c(\"year\", \"partial_series\", \"year\", \"year\", \"year\"),\n    Timeline_Start = c(1, 1, 2, 1, 3),\n    Timeline_End = c(3, 4, 5, 1, 2),\n    Timeline_Freq = c(1, 1, 2, 1, NA),\n    `Imp/Exp` = \"Imp\",\n    SACO_link = NA,\n  )\n  expected &lt;- tibble::tibble(\n    Name = c(\"a_1\", \"a_2\", \"a_3\", \"b\", \"b\", \"b\", \"b\", \"c_2\", \"c_4\"),\n    Trade = c(\"t1\", \"t1\", \"t1\", \"t2\", \"t2\", \"t2\", \"t2\", \"t3\", \"t3\"),\n    Info_Format = c(\n      \"year\", \"year\", \"year\", \"partial_series\", \"partial_series\",\n      \"partial_series\", \"partial_series\", \"year\", \"year\"\n    ),\n    Year = c(1, 2, 3, 1, 2, 3, 4, 2, 4),\n  )\n\n  actual &lt;-\n    trade_sources |&gt;\n    expand_trade_sources() |&gt;\n    dplyr::ungroup()\n\n  expect_equal(\n    dplyr::select(actual, Name, Trade, Info_Format, Year),\n    expected\n  )\n})\nAgain, you do not have to understand the whole code. Just note that we use two functions from the testthat package:\n\ntestthat::test_that: this is the main function used to delimit what a test is. It receives a text description about what the test is checking, and a body containing all the code of the test itself.\ntestthat::expect_equal: this is just one of the many utilities testthat brings to actually assert things in the test’s code. It is probably the most general assert, and it just checks if everything is identical in both arguments, including internal object metadata, not just “appearance” (what you may see when printing an object). You can look for more testing utility functions in their documentation.\n\nSo now we have a test. How do we execute it? It is not recommended to run the test as usual R code (e.g. run the file as a script). Instead, there are some functions provided by testthat for running tests. Here are some of them:\n\ntestthat::auto_test_package(): This one will run all the tests in the package the first time, and after that it will not stop running, but wait for code changes. This means that whenever you ‘save’ a test file, it only reruns all the tests in that file. This is extremely useful when you are actively writing some tests, so that you can get fast feedback.\ntestthat::test_file(): This one receives as argument the path to a test file, and it only runs the tests inside it. For example, we could run in our case testthat::test_file(\"tests/testthat/test-sources.R\").\ntestthat::test_dir(): In this case, this could be different to running all the tests if we had e.g. some subdirectories in the tests/testthat one. If there was a subdirectory tests/testthat/sources with many test files related to sources, we could run testthat::test_dir(\"tests/testthat/sources\") and all test files inside this directory would be executed.\ntestthat::test_package(): This is the most general one. It just runs all the tests in the project.\n\nAll of these can be useful to run tests while you are actively working on them. You are supposed to make all your tests pass, and as we will see in the next section, there are some more checks a package must pass to be valid (so that it can be publicly uploaded), but tests are definitely one of them.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Writing tests</span>"
    ]
  },
  {
    "objectID": "r-cmd-check.html",
    "href": "r-cmd-check.html",
    "title": "14  R CMD Check",
    "section": "",
    "text": "There is a standard tool that contains several steps (‘checks’) which every project that wants to be a package uploaded to CRAN repositories must pass. As part of our code workflow, you are also responsible to make this check pass, as we will also see in the Automatic checks on Pull Requests section. This check is known as ‘R CMD check’, and it is actually very easy to run:\ndevtools::check()\nThe whole output of this call is rather long, since it lists all the different checks it makes, but at the end, if there are no issues, this is the output you should see:\n\n\n\n\n\n\n\n\n\nOK, but if you just followed the steps in this guide and included our example code from the Writing code and Writing tests sections, the above check should not have ended successfully with 0 errors, and you probably see (among the really large output), some error like this:\n\n\n\n\n\n\n\n\n\nThe problem here is that before performing the check on your package, it must build it. And for that, it must know which other packages it has as dependencies. Again, if you just followed everything from here, we never got to do that, so your built package just does not include any other packages. To fix this, we must have a quick look at the DESCRIPTION file.\nPackage: whep\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R:\n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"))\nDescription: What the package does (one paragraph).\nLicense: MIT + file LICENSE\nImports:\n    dplyr,\n    tidyr\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.2\nSuggests:\n    knitr,\n    rmarkdown,\n    testthat (&gt;= 3.0.0),\n    tibble,\n    ggplot2,\n    here,\n    googlesheets4\nConfig/testthat/edition: 3\nVignetteBuilder: knitr\nURL: https://eduaguilera.github.io/whep/\nIn the above file, the Imports section is where we should make sure we have all dependencies for code which was saved specifically in the R/ directory. On the other hand, dependencies for code written in other places, such as tests/ or vignettes/ (we will see this one in the following Writing articles section), should be included in the Suggests section of the DESCRIPTION file. Together these two fields tell everyone which dependencies our package needs to work correctly. After adding these, you could run again devtools::check() and confirm that it does not fail anymore (at least no errors).\nWe will not go into detail as to which checks are being performed. We will all slowly learn about them whenever they show up as real issues in our code when running the check tool. Just keep in mind that one of the important points is that all the tests you write are also executed here, and the ‘R CMD check’ also fails if one of your tests fail. If you really want to know more about the checks, you can read, e.g., this detailed list.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R CMD Check</span>"
    ]
  },
  {
    "objectID": "write-articles.html",
    "href": "write-articles.html",
    "title": "15  Writing articles",
    "section": "",
    "text": "If you ever got to check some popular R package website (e.g. dplyr), you may know there is a section called Articles at the top, and if you open one of them, you see what indeed looks like an article, mixing natural text and code rendering. This is ideal if you want to make guides about your package, or some kind of reports in general. As you can probably guess, this guide that you are reading was built the same way. Luckily this is already very well integrated with the R packages workflow, and we will learn how to make our own articles here easily.\nEverything that we want to appear in this Articles section of the site, should be included in the vignettes/ directory of the package. And inside this directory, each file that ends with a .Rmd extension will be considered one article. The extension name stands for ‘R Markdown’, which is a mix of R code and Markdown text. If you do not know about Markdown you can start with, e.g., this intro. Following our previous example, we can create a file called trade-sources-coverage.Rmd with the following code 1 (again, thanks to Justin):\nThe first part of this code, namely the following\nis metadata and should always be present (just change the article’s title). You see that just as in Markdown, we can write R code chunks inside triple backticks, but the difference here is that this code will be executed, and by default we will also be able to see its output in the rendered article.\nThe next chunk (with the \"r setup\" option) is used for some initialization code that you may need throughout the rest of the article. At the time of writing I do not really know the implications of writing the \"r setup\" option or writing this code in a normal R code chunk (without the option), but it is at least good practice. Note that the package being loaded is your own package (called whep in our case).\nThe rest of the code provided is just some usual Markdown text intertwined with usual R code chunks. In the special case of code chunks with plots, we will get to see the actual plot in the rendered article, and the fig.alt option is necessary in order not to get an R CMD check warning, and will only be used as text which explains the rendered image for people using screen readers or in the case it cannot be displayed correctly in a browser.\nNow that we have our R Markdown article, we would like to visualize it. There are at least two useful R commands for this. The first one creates the whole documentation website locally in our computers, and it automatically opens your browser on the site. This is simply:\nWe should now be able to see our article in the ‘Articles’ section. It should look something like the one you can see directly on this site at Trades sources coverage (with some additional plots).\nAfter running this command once, there is no need to rerun it every time we want to see changes, since it takes a bit longer to run. We can instead use a simpler one\nwhich checks for code changes in articles and only reruns those that have changed. I am not completely convinced they are equivalent, since it seems at some point one failed and one worked for me, but if you are not doing something strange (like me building this guide and writing R Markdown inside R Markdown) it should probably work the same.\nThe pkgdown::build_articles() one could still fail with some error indicating that the package cannot be loaded. It most likely refers to your own package. Since you use code from your own package inside the R markdown, this package itself must also be installed. When running pkgdown::build_site(), I think the package is installed but only in a temporary directory for that execution, so maybe it does not work anymore when calling pkgdown::build_articles() after that. If this is your case, you may want to try installing your own package first via devtools::install(). Note that this assumes you do not change your package code (the one in R/ directory) while actively working on articles. If you do, you would have to reinstall your own package every time you change something in the R/ directory.\nAs mentioned in a previous section, also remember to include all package dependencies your article code uses in the Suggests part of the DESCRIPTION file, so that you do not get errors of packages not being found when building the articles or running R CMD check.\nThis way we can render our articles by default in HTML, which is what browsers use. Having your own site is perfect because you can keep it up to date, but in case you need it, you should also be able to export an article as PDF. For this to work, you first need a LaTeX distribution installed. If you are on Windows, you can try MiKTeX (maybe start from here). Remember to choose “Yes” when asked for “missing packages installation on the fly”, otherwise our PDF generation from R might fail. Once we have a LaTeX distribution installed, we can build a PDF from our article with just a single command:\nThe output PDF (probably as expected) does not look exactly like the one from the site, but it has its own style (LaTeX’s style). There are also other valid formats, you can look them up if you are curious, but I thought the PDF output format would be the most useful one besides the HTML for website generation.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Writing articles</span>"
    ]
  },
  {
    "objectID": "write-articles.html#footnotes",
    "href": "write-articles.html#footnotes",
    "title": "15  Writing articles",
    "section": "",
    "text": "If you copy it, please remove the _ from starting code block lines, e.g., change ```_{r, ...} to ```{r, ...}. I cannot render R Markdown code properly inside an R Markdown file itself in this guide, because it tries to execute the code block anyway, and this is a workaround so that this guide renders properly. Do tell me if you know of a correct way to handle this.↩︎",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Writing articles</span>"
    ]
  },
  {
    "objectID": "envs-and-secrets.html",
    "href": "envs-and-secrets.html",
    "title": "16  Environment variables and secrets",
    "section": "",
    "text": "When running code, you can sometimes customize some behavior by specifying the value of some variable to your needs. For example, maybe there is an option whose value is a number from 1 to 5, indicating the level of debugging (the amount of output you want to see in the console, so as to understand the code’s execution). A possible way of introducing this would be with what is known as an ‘environment variable’, which is just a value stored with a name in the ‘environment’ where your code runs (not an R variable, it is more related to the operating system). These should be loaded before the code starts running, and our package workflow allows us to do this quite easily, by creating a top-level file called .Renviron, which can include one variable per line, like this:\nIt can be accessed from R code by using\nYou can also use environment variables for constants, or whatever you feel that could be used in several places. This file will be uploaded to the repository, so it is important that it does not contain any sensitive information (also known as ‘secrets’). I also introduced this section because in the example code for the Writing articles section, there is the line:\nIn that example, an Excel sheet must be read. When using the googlesheets4 package, it can automatically open a browser interactively and ask for your Google account credentials, but when running check tools, we want everything to work from beginning to end without human intervention. This is achievable by providing a secret token 1.\nSince we must not include secret information in .Renviron, the workaround is to instead add just the secret file path as an environment variable and then read from it, so the .Renviron is uploaded to GitHub but the secret file, which according to our environment variable should be found in inst/google_cloud_key.json, is not uploaded. Instead, the file should be uploaded to another private storage service, so that only you have access to it.\nIn examples like this one, ideally every developer would create and use their own token. The specific case of the token in this example is out of the scope of this guide, but if you are interested you could probably start from this gargle package guide. Also, the here package was used above for easy file path referencing from the root directory of a project, so that paths are not hard-coded, and you can read more in their package site.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Environment variables and secrets</span>"
    ]
  },
  {
    "objectID": "envs-and-secrets.html#footnotes",
    "href": "envs-and-secrets.html#footnotes",
    "title": "16  Environment variables and secrets",
    "section": "",
    "text": "For educational purposes I won’t change anything from this explanation in the guide. However, recently I found out that the token is not needed when you’re reading public files. For this to work automatically we only have to call googlesheets4::gs4_deauth() before reading the public file.↩︎",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Environment variables and secrets</span>"
    ]
  },
  {
    "objectID": "code-style.html",
    "href": "code-style.html",
    "title": "17  R code style and formatting",
    "section": "",
    "text": "There are some conventions and good practices for how to write neat code in R. The most followed style guide is the Tidyverse style guide. You can read it or just skim through it to get a grasp of their conventions. The key is that most of them can be checked automatically. There are tools which conform to these standards and let you apply the necessary changes to the code by just clicking one button. Analogously, there are also ways to check whether a code is correctly following a style or not, without explicitly changing it. In the context of the Tidyverse style guide, these two points directly match with two R packages:\n\nstyler: it applies the Tidyverse style guide to a specific code, be it a chunk, a file or an entire project. For example, we could apply the style to the whole package by simply using the command:\nstyler::style_pkg()\nMost code editors incorporate some way of doing this. Since you are most likely using RStudio, you can do it by finding the styler options in the ‘addins’ drop-down:\n\nprint(\"this is code change\")\n\n[1] \"this is code change\"\n\n\n\n\n\n\n\n\n\n\n\nWhen using renv, it seems RStudio only shows in the ‘addins’ drop-down the options from packages included in renv, so keep that in mind in case you want it in a different project, that is, if styler does not show up there, it means you do not have it installed in the current renv environment.\nAn important thing to keep in mind is that the Tidyverse style guide states lines should have at most 80 characters, but the styler package cannot by itself try to separate a really long single line into several lines to match the 80 character limit. You must fix this anyway, and the usual way for the styler to work is to first manually split some of the code into two lines, and then run the styler again, so it can now split the rest accordingly. For example, you have:\ncall_my_incredibly_long_function(my_first_long_argument, my_second_long_argument, my_third_long_argument)\nIn this case, if you use styler it may not change anything and still leave this code in a single line, but you can help it a bit by sending the arguments to the next line, like this:\ncall_my_incredibly_long_function(\n  my_first_long_argument, my_second_long_argument, my_third_long_argument)\nThis does not conform to the standard yet, but now trying to use styler again, it should be able to understand what is going on and split the code accordingly. Depending on the length of the line, it may leave it like this (note the closing parenthesis goes in its own line):\ncall_my_incredibly_long_function(\n  my_first_long_argument, my_second_long_argument, my_third_long_argument\n)\nOr if the line was even longer, it would split each argument into its own line:\ncall_my_incredibly_long_function(\n  my_first_long_argument,\n  my_second_long_argument,\n  my_third_long_argument,\n  my_fourth_long_argument\n)\nAny of those should work now, because they successfully follow the 80 character per line limit. If you do not follow the limit, you would fail the lintr check (see next point below).\nlintr: it checks whether the given code/file/project follows the Tidyverse style guide, without making any actual changes. You are responsible for making sure this check passes (probably using styler as explained above), since it will also be automatically checked on your Pull Requests (see the next section on this guide). The check we will use is:\nlintr::lint_package(\n  linters = lintr::linters_with_defaults(object_usage_linter = NULL)\n)\nThe default call would be as easy as lintr::lint_package(). I will not go into detail about the specific option added here, but it is there to ignore warnings about undeclared global variables, which are false positives when using dplyr column names. For convenience, if you are following our example repository, you could find this call in inst/scripts/check_lint.R, so if you want to check everything you would just have to run this script.\nIn the screenshot above you can see there are also options for lintr checks from Rstudio’s ‘addins’, but by default they perform the lintr::lint_package() call without any options. Remember we added one option to our check, so you should either find out how to change the default behavior or just run the script we included in inst/scripts/check_lint.R.\n\nAgain, as you can see in the screenshot, there are more things you can do directly from RStudio (like running tests or building documentation). In this guide I tried to provide a code editor agnostic approach for everything. Since I do not use RStudio myself, I am not particularly familiar with its functionalities, so if you think they may be helpful to you, you can check them yourself.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>R code style and formatting</span>"
    ]
  },
  {
    "objectID": "read-large-files.html",
    "href": "read-large-files.html",
    "title": "18  Reading large files",
    "section": "",
    "text": "Many packages don’t work with data per se. Others need data, but their datasets are small enough to be directly included in the package (and thus the code repository). GitHub has a limit on file size of 100 MiB, but even adding such files will make working with the repository noticeably slow. My recommendation for us is to consider a file large if it has more than a couple of megabytes. Assuming our package needs to work with large files, we need to find a workaround that is not storing them in GitHub. After thinking about this for a while, I considered using the pins package. I encourage you to read through that Get started guide, since I won’t explain too much about this package itself, but rather how we implement it in our workflow.\nA pins board is like a repository but for files. You can even store a version history of them. Here we assume that someone already created a board for you. If you just want to use a file someone else already added, you don’t need any of the following. See the documentation for whep_read_file(). However, if you need a new file that is still not uploaded, or a new version of an existing one, you’ll need to do these steps:\n\nPrepare a local version of your data. I created a script helper for us, which can be found in the whep repository. You have to fill your own local data path and a name for the data, run the script and follow the instructions. For example, I could set the following\n\nprepare_for_upload(\n  \"~/Downloads/Processing_coefs.csv\",\n  \"processing_coefs\"\n)\n#&gt; Creating new version '20250716T102305Z-f8189'\n#&gt; ℹ 1. Manually upload the folder /tmp/RtmpHFHNUO/pins-1f3c39c418e0/processi\n#&gt; ng_coefs/20250716T102305Z-f8189 into your board. Folder path copied to you\n#&gt; r clipboard.\n#&gt; ℹ 2. Add the corresponding line\n#&gt; - processing_coefs/20250716T102305Z-f8189/\n#&gt; in _pins.yaml at the end of the 'processing_coefs:' section\n#&gt; ℹ 3. If you want the package to use this version, add a new row to whep_in\n#&gt; puts.csv if it's a new file or update the version in the existing row. The\n#&gt;  version is 20250716T102305Z-f8189.\n\nA temporary local folder is created whose name is the data version. You must upload this folder inside the one with the data’s name in the public board, assuming you have write access.\n\n\n\n\nNew version uploaded\n\n\n\nYou must add one line to the _pins.yaml file in the root folder of the board, like it’s specified in the instructions. This is an internal file that the pins package uses to keep track of files and versions.\n\n\n\n\nUpdate _pins.yaml\n\n\n\nTo use the version in the next package release, you must also update the version inside the whep_inputs.csv file:\n\nalias,board_url,version\n...\nprocessing_coefs,https://some/url/to/_pins.yaml,20250716T102305Z-f8189\n...\nAnd now you’re done. You added a new file or a new version, and you can now access it from the code by using the whep_read_file() function.\nIf you’re wondering why there are manual steps in this process and the script doesn’t automate everything, it’s because our storage service is hosted by a Nextcloud server, and the easiest way to interact with it from outside is having a synced version of the whole storage locally. I thought some people might not be able to afford that, and since we don’t have to upload new data files often, I decided a few manual steps wouldn’t hurt that much.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Reading large files</span>"
    ]
  },
  {
    "objectID": "pr-auto-checks.html",
    "href": "pr-auto-checks.html",
    "title": "19  Automatic checks on Pull Requests",
    "section": "",
    "text": "By this point we assume you are already done with all your new code, you documented and tested it, or perhaps you just created some report in the form of an article. As we have seen in the Git intro, it is now time to create a Pull Request so that someone else reviews what you have done. But when you create the Pull Request, our workflow is designed so that two checks are run automatically on GitHub, each time you push your changes to a branch which has an open Pull Request:\n\nFirst, the R CMD check is performed. We have seen in a previous section how you can run it locally, so you should have made sure it outputs no errors. Otherwise, you will see this step failing.\nThen, a linting check is performed. We have also seen how to autoformat your code, so that it follows the R code styling standards, and how to make sure that it is indeed well formatted. Otherwise, you will see this step failing.\n\nIf any of the steps above fail, you will see something like this in your PR page:\n\n\n\n\n\n\n\n\n\nOtherwise, if both checks succeeded, you will see something like:\n\n\n\n\n\n\n\n\n\nOverall, you should be able to see this at the bottom of the PR:\n\n\n\n\n\n\n\n\n\nIn case you are wondering, both checks we mentioned before are actually done in a single GitHub automatic step (these steps are called ‘GitHub actions’), so it should say ‘1 successful check’ instead of ‘2 successful checks’. However, there is an additional GitHub action there, which essentially just updates the documentation site (only when the PR is actually merged into the main branch). This is not relevant to you as a developer but it makes the overall workflow easier, since the project documentation is automatically updated without any more human intervention. If you want to know more about this automatic site update you can check this section from the R Packages book.\nRecall that for a PR to be accepted and merged into the main branch, it must also be reviewed by another developer. A good practice would be to make sure the GitHub checks pass before even asking for someone’s reviewing, because if any check failed you most likely need to add more code changes to fix them, so some of the code the reviewer could have checked before could become obsolete, and they would have to read it again, so we better avoid that.",
    "crumbs": [
      "Create an R package",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Automatic checks on Pull Requests</span>"
    ]
  }
]