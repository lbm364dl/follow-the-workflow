{
  "hash": "d5db2d9c4d692a4571e0f565d75e93c1",
  "result": {
    "engine": "knitr",
    "markdown": "## R code style and formatting\n\nThere are some conventions and good practices for how to write neat code\nin R. The most followed style guide is the\n[Tidyverse style guide](https://style.tidyverse.org/). You can read it or just\nskim through it to get a grasp of their conventions. The key is that most of them\ncan be checked automatically. There are tools which conform to these standards\nand let you apply the necessary changes to the code by just clicking one button.\nAnalogously, there are also ways to check whether a code is correctly following\na style or not, without explicitly changing it. In the context of the Tidyverse\nstyle guide, these two points directly match with two R packages:\n\n- `styler`: it applies the Tidyverse style guide to a specific code, be it a chunk,\n  a file or an entire project. For example, we could apply the style to the whole\n  package by simply using the command:\n\n  ```r\n  styler::style_pkg()\n  ```\n\n  Most code editors incorporate some way of doing this. Since you are most likely\n  using RStudio, you can do it by finding the `styler` options in the 'addins' drop-down:\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  print(\"this is code change\")\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] \"this is code change\"\n  ```\n  \n  \n  :::\n  :::\n\n\n\n  ::: {.cell}\n  ::: {.cell-output-display}\n  ![](imgs/styler_rstudio.png){fig-alt='Use styler package from RStudio'}\n  :::\n  :::\n\n\n  When using `renv`, it seems RStudio only shows in the 'addins' drop-down the\n  options from packages included in `renv`, so keep that in mind in case you want\n  it in a different project, that is, if `styler` does not show up there, it means\n  you do not have it installed in the current `renv` environment.\n\n  An important thing to keep in mind is that the Tidyverse style guide states lines\n  should have at most 80 characters, but the `styler` package cannot by itself try\n  to separate a really long single line into several lines to match the 80 character\n  limit. You _must_ fix this anyway, and the usual way for the `styler` to work\n  is to first manually split some of the code into two lines, and then run the\n  `styler` again, so it can now split the rest accordingly. For example, you have:\n\n  ```r\n  call_my_incredibly_long_function(my_first_long_argument, my_second_long_argument, my_third_long_argument)\n  ```\n\n  In this case, if you use `styler` it may not change anything and still leave\n  this code in a single line, but you can help it a bit by sending the arguments\n  to the next line, like this:\n\n  ```r\n  call_my_incredibly_long_function(\n    my_first_long_argument, my_second_long_argument, my_third_long_argument)\n  ```\n\n  This does not conform to the standard yet, but now trying to use `styler` again,\n  it should be able to understand what is going on and split the code accordingly.\n  Depending on the length of the line, it may leave it like this (note the closing\n  parenthesis goes in its own line):\n\n  ```r\n  call_my_incredibly_long_function(\n    my_first_long_argument, my_second_long_argument, my_third_long_argument\n  )\n  ```\n\n  Or if the line was even longer, it would split each argument into its own line:\n\n  ```r\n  call_my_incredibly_long_function(\n    my_first_long_argument,\n    my_second_long_argument,\n    my_third_long_argument,\n    my_fourth_long_argument\n  )\n  ```\n\n  Any of those should work now, because they successfully follow the 80 character\n  per line limit. If you do not follow the limit, you would fail the `lintr`\n  check (see next point below).\n\n- `lintr`: it checks whether the given code/file/project follows the Tidyverse\n  style guide, without making any actual changes. You are responsible for making\n  sure this check passes (probably using `styler` as explained above), since it\n  will also be automatically checked on your Pull Requests (see the\n  [next section](#automatic-checks-on-pull-requests) on this guide). The check\n  we will use is:\n  ```r\n  lintr::lint_package(\n    linters = lintr::linters_with_defaults(object_usage_linter = NULL)\n  )\n  ```\n  The default call would be as easy as `lintr::lint_package()`. I will not go into\n  detail about the specific option added here, but it is there to ignore warnings\n  about undeclared global variables, which are false positives when using `dplyr`\n  column names. For convenience, if you are following our\n  [example repository](https://github.com/lbm364dl/R-example), you could find this\n  call in `inst/scripts/check_lint.R`, so if you want to check everything you would\n  just have to run this script.\n\n  In the screenshot above you can see there are also options for `lintr` checks\n  from Rstudio's 'addins', but by default they perform the `lintr::lint_package()`\n  call without any options. Remember we added one option to our check, so you\n  should either find out how to change the default behavior or just run the\n  script we included in `inst/scripts/check_lint.R`.\n\nAgain, as you can see in the screenshot, there are more things you can do\ndirectly from RStudio (like running tests or building documentation). In this\nguide I tried to provide a code editor agnostic approach for everything. Since\nI do not use RStudio myself, I am not particularly familiar with its\nfunctionalities, so if you think they may be helpful to you, you can check\nthem yourself.\n",
    "supporting": [
      "code-style_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}